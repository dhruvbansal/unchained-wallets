<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: trezor.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: trezor.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Provides classes for interacting with Trezor hardware wallets.
 *
 * The base class provided is `TrezorInteraction` which wraps calls to [`TrezorConnect`]{@link https://github.com/trezor/connect}.  New interactions should subclass `TrezorInteraction`.
 *
 * Many Trezor calls require knowing the bitcoin network.  This
 * library uses the API defined by `unchained-bitcoin` to label
 * bitcoin networks, and this is the value expected in several off the
 * constructors for classes in this module.
 *
 * The value of the `network` is mapped internally to
 * `this.trezorCoin`.  This value is useful to subclasses implementing
 * the `params()` method as many TrezorConnect methods require the
 * `coin` parameter.
 *
 * The following API classes are implemented:
 *
 * * TrezorGetMetadata
 * * TrezorExportPublicKey
 * * TrezorExportExtendedPublicKey
 * * TrezorSignMultisigTransaction
 * * TrezorConfirmMultisigAddress
 *
 * @module trezor
 */
import BigNumber from "bignumber.js";
import {
  MAINNET,
  TESTNET,
  bip32PathToSequence,
  multisigAddress,
  multisigPublicKeys,
  multisigRequiredSigners,
  multisigAddressType,
  P2SH,
  P2SH_P2WSH,
  P2WSH,
} from "unchained-bitcoin";

import {
  DirectKeystoreInteraction,
  PENDING,
  ACTIVE,
  INFO,
  ERROR,
  WARNING,
} from "./interaction";

/**
 * Constant defining Trezor interactions.
 *
 * @type {string}
 * @default trezor
 */
export const TREZOR = 'trezor';

const TrezorConnect = require("trezor-connect").default;

const ADDRESS_SCRIPT_TYPES = {
  [P2SH]: 'SPENDMULTISIG',
  [P2SH_P2WSH]: 'SPENDP2SHWITNESS',
  [P2WSH]: 'SPENDWITNESS',
}

try {
  TrezorConnect.manifest({email: "help@unchained-capital.com", appUrl: "https://github.com/unchained-capital/unchained-wallets"});
} catch(e) {
  // We hit this if we run this code outside of a browser, for example
  // during unit testing.
  console.error("Unable to call TrezorConnect.manifest.");
}

/**
 * Base class for interactions with Trezor hardware wallets.
 *
 * Assumes we are using TrezorConnect to talk to the device.
 *
 * Subclasses *must* implement a method `this.connectParams` which
 * returns a 2-element array.  The first element of this array should
 * be a `TrezorConnect` method to use (e.g. -
 * `TrezorConnect.getAddress`).  The second element of this array
 * should be the parameters to pass to the given `TrezorConnect`
 * method.
 *
 * Errors thrown when calling TrezorConnect are not caught, so users
 * of this class (and its subclasses) should use `try...catch` as
 * always.
 *
 * Unsuccessful responses (the request succeeded but the Trezor device
 * returned an error message) are intercepted and thrown as errors.
 * This allows upstream `try...catch` blocks to intercept errors &amp;
 * failures uniformly.
 *
 * Subclasses *may* implement the `parse(payload)` method which
 * accepts the response payload object and returns the relevant data.
 *
 * Subclasses will also want to implement a `messages()` method to
 * manipulate the messages returned to the user for each interaction.
 *
 * @extends {module:interaction.DirectKeystoreInteraction}
 * @example
 * import {TrezorInteraction} from "unchained-wallets";
 * // Simple subclass
 *
 * class SimpleTrezorInteraction extends TrezorInteraction {
 *
 *   constructor({network, param}) {
 *     super({network});
 *     this.param =  param;
 *   }
 *
 *   connectParams() {
 *     return [
 *       TrezorConnect.doSomething, // Not a real TrezorConnect function...
 *       {
 *         // Many Trezor methods require the `coin` parameter.  The
 *         // value of `this.trezorCoin` is set appropriately based on the
 *         // `network` provided in the constructor.
 *         coin: this.trezorCoin,
 *
 *         // Pass whatever arguments are required
 *         // by the TrezorConnect function being called.
 *         param: this.param,
 *         // ...
 *       }
 *     ];
 *   }
 *
 *   parse(payload) {
 *     return payload.someValue;
 *   }
 * 
 * }
 *
 * // usage
 * import {MAINNET} from "unchained-bitcoin";
 * const interaction = new SimpleTrezorInteraction({network: MAINNET, param: "foo"});
 * const result = await interaction.run();
 * console.log(result); // someValue from payload
 */
export class TrezorInteraction extends DirectKeystoreInteraction {

  /**
   * Trezor interactions require knowing the bitcoin network they are
   * for.
   *
   * @param {object} options
   * @param {string} options.network - bitcoin network
   */
  constructor({network}) {
    super();
    this.network = network;
    this.trezorCoin = trezorCoin(network);
  }

  /**
   * Default messages are added asking the user to plug in their
   * Trezor device (`device.connect`) and about the TrezorConnect
   * popups (`trezor.connect.generic`).
   *
   * Subclasses should override this method and add their own messages
   * (don't forget to call `super()`).
   *
   * @returns {module:interaction.Message[]} messages
   */
  messages() {
    const messages = super.messages();
    messages.push({state: PENDING, level: INFO, text: "Make sure your Trezor device is plugged in.", code: "device.connect"});
    messages.push({state: ACTIVE, level: INFO, text: "Your browser should open a new Trezor Connect window.  If you do not see this window, ensure you have enabled popups for this site.", code: "trezor.connect.generic"});
    return messages;
  }

  /**
   * Awaits the call of `this.method`, passing in the output of
   * `this.params()`.
   *
   * If the call returns but is unsuccessful (`result.success`) is
   * false, will throw the returned error message.  If some other
   * error is thrown, it will not be caught.
   *
   * Otherwise it returns the result of passing `result.payload` to
   * `this.parse`.
   *
   * @returns {Promise}
   */
  async run() {
    const [method, params] = this.connectParams();
    const result = await method(params);
    if (!result.success) {
      throw new Error(result.payload.error);
    }
    return this.parse(result.payload);
  }

  /**
   * Override this method in a subclass to return a 2-element array.
   *
   * The first element should be a functin to call, typically a
   * `TrezorConnect` method, e.g. `TrezorConnect.getAddress`.
   *
   * The second element should be the parameters to pass to this
   * function.
   *
   * By default, the function passed just throws an error.
   *
   * @returns {Array&lt;function,Object>}
   */
  connectParams() {
    return[
      (params) => { throw new Error("Override the `connectParams` method on a subclass of TrezorInteraction."); },
      {},
    ];
  }

  /**
   * Override this method in a subclass to parse the payload of a
   * successful response from the device.
   *
   * By default, the entire payload is returned.
   *
   * @param {Object} payload
   * @returns {Object}
   */
  parse(payload) {
    return payload;
  }
  
}

/**
 * Returns metadata about Trezor device.
 *
 * Includes model name, device label, firmware version, &amp;
 * PIN/passphrase enablement.
 *
 * @extends {module:trezor.TrezorInteraction}
 * @example
 * import {TrezorGetMetadata} from "unchained-wallets";
 * const interaction = new TrezorGetMetadata();
 * const result = await interaction.run();
 * console.log(result);
 * {
 *   spec: "Model 1 v1.8.3 w/PIN",
 *   model: "Model 1",
 *   version: {
 *     major: 1,
 *     minor: 8,
 *     patch: 3,
 *     string: "1.8.3",
 *   },
 *   label: "My Trezor",
 *   pin: true,
 *   passphrase: false,
 * }
 */
export class TrezorGetMetadata extends TrezorInteraction {

  /**
   * This class doesn't actually require a `network`.
   *
   * @constructor
   */
  constructor() {
    super({});
  }

  /**
   * It is underdocumented, but TrezorConnect does support the
   * `getFeatures` API call.
   *
   * See {@link https://github.com/trezor/connect/blob/v8/src/js/core/methods/GetFeatures.js}.
   *
   * @returns {Array&lt;function, Object>}
   */
  connectParams() {
    return [
      TrezorConnect.getFeatures,
      {},
    ];
  }

  /**
   * Parses Trezor device featuress into an appropriate metadata
   * shape.
   *
   * @param {Object} payload
   * @returns {Object}
   */
  parse(payload) {
    // Example result:
    // 
    // {
    //   bootloader_hash: "5112...846e9"
    //   bootloader_mode: null
    //   device_id: "BDF9...F198"
    //   firmware_present: null
    //   flags: 0
    //   fw_major: null
    //   fw_minor: null
    //   fw_patch: null
    //   fw_vendor: null
    //   fw_vendor_keys: null
    //   imported: false
    //   initialized: true
    //   label: "My Trezor"
    //   language: null
    //   major_version: 1
    //   minor_version: 6
    //   model: "1"
    //   needs_backup: false
    //   no_backup: null
    //   passphrase_cached: false
    //   passphrase_protection: false
    //   patch_version: 3
    //   pin_cached: true
    //   pin_protection: true
    //   revision: "ef8...862d7"
    //   unfinished_backup: null
    //   vendor: "bitcointrezor.com"
    // }
    const {
      major_version, minor_version, patch_version,
      label,
      model,
      pin_protection, passphrase_protection,
    } = payload;
    let spec = `Model ${model} v.${major_version}.${minor_version}.${patch_version}`;
    if (pin_protection) {
      spec += " w/PIN";
    }
    if (passphrase_protection) {
      spec += " w/PASS";
    }
    return {
      spec,
      model: `Model ${model}`,
      version: {
        major: major_version,
        minor: minor_version,
        patch: patch_version,
        string: `${major_version}.${minor_version}.${patch_version}`,
      },
      label,
      pin: pin_protection,
      passphrase: passphrase_protection,
    };
  }

}


/**
 * Base class for interactions exporting information about an HD node
 * at a given BIP32 path.
 *
 * You may want to use `TrezorExportPublicKey` or
 * `TrezorExportExtendedPublicKey` directly.
 *
 * @extends {module:trezor.TrezorInteraction}
 * @example
 * import {MAINNET} from "unchained-bitcoin";
 * import {TrezorExportHDNode} from "unchained-wallets";
 * const interaction = new TrezorExportHDNode({network: MAINNET, bip32Path: "m/48'/0'/0'/2'/0"});
 * const node = await interaction.run();
 * console.log(node); // {publicKey: "", xpub: "", ...}
 * 
 */
export class TrezorExportHDNode extends TrezorInteraction {

  /**
   * Requires a BIP32 path to the node to export as well as which network.
   * 
   * @param {object} options
   * @param {string} options.network - bitcoin network
   * @param {string} bip32Path - the BIP32 path for the HD node
   */
  constructor({network, bip32Path}) {
    super({network});
    this.bip32Path = bip32Path;
  }

  /**
   * Adds messages related to warnings Trezor devices make depending
   * on the BIP32 path passed.
   * 
   * @returns {module:interaction.Message[]}
   */
  messages() {
    const messages = super.messages();

    const bip32PathSegments = (this.bip32Path || '').split('/');
    if (bip32PathSegments.length &lt; 4) { // m, 45', 0', 0', ...
      messages.push({state: PENDING, level: ERROR, text: "BIP32 path must be at least depth 3.", code: "trezor.bip32_path.minimum"});
    } else {
      const coinPath = bip32PathSegments[2];
      if (this.network === MAINNET) {
        if (! coinPath.match(/^0'/)) {
          messages.push({state: ACTIVE, level: WARNING, text: "On Trezor model T the screen may display a 'Confirm path' warning message.", code: "trezor.bip32_path.mismatch"});
        }
      }
      if (this.network === TESTNET) {
        if (! coinPath.match(/^1'/)) {
          messages.push({state: ACTIVE, level: WARNING, text: "On Trezor model T the screen may display a 'Confirm path' warning message.'", code: "trezor.bip32_path.mismatch"});
        }
      }
    }

    messages.push({state: ACTIVE, level: INFO, text: "Confirm in the Trezor Connect window that you want to 'Export public key'.  You may be prompted to enter your PIN.", code: "trezor.connect.export_hdnode"});

    return messages;
  }

  /**
   * See {@link https://github.com/trezor/connect/blob/v8/docs/methods/getPublicKey.md}.
   *
   * @returns {Object}
   */
  connectParams() {
    return [
      TrezorConnect.getPublicKey,
      {
        path: this.bip32Path,
        coin: this.trezorCoin,
        crossChain: true,
      },
    ];
  }

}

/**
 * Returns the public key at a given BIP32 path.
 * 
 * @extends {module:trezor.TrezorExportHDNode}
 * @example
 * import {MAINNET} from "unchained-bitcoin";
 * import {TrezorExportPublicKey} from "unchained-wallets";
 * const interaction = new TrezorExportPublicKey({network: MAINNET, bip32Path: "m/48'/0'/0'/2'/0"});
 * const publicKey = await interaction.run();
 * console.log(publicKey);
 * // "03..."
 */
export class TrezorExportPublicKey extends TrezorExportHDNode {

  /**
   * Parses the public key from the HD node response.
   *
   * @param {object} payload
   * @returns {string} the (compressed) public key in hex
   */
  parse(payload) {
    return payload.publicKey;
  }

}

/**
 * Returns the extended public key at a given BIP32 path.
 * 
 * @extends {module:trezor.TrezorExportHDNode}
 * @example
 * import {MAINNET} from "unchained-bitcoin";
 * import {TrezorExportExtendedPublicKey} from "unchained-wallets";
 * const interaction = new TrezorExportExtendedPublicKey({network: MAINNET, bip32Path: "m/48'/0'/0'"});
 * const xpub = await interaction.run();
 * console.log(xpub);
 * // "xpub..."
 */
export class TrezorExportExtendedPublicKey extends TrezorExportHDNode {

  /**
   * Parses the extended public key from the HD node response.
   *
   * @param {object} payload
   * @returns {string} the extended public key
   */
  parse(payload) {
    return payload.xpub;
  }

}

/**
 * Returns a signature for a bitcoin transaction with inputs from one
 * or many multisig addresses.
 *
 * - `inputs` is an array of `UTXO` objects from `unchained-bitcoin`
 * - `outputs` is an array of `TransactionOutput` objects from `unchained-bitcoin`
 * - `bip32Paths` is an array of (`string`) BIP32 paths, one for each input, identifying the path on this device to sign that input with
 * 
 * @example
 * import {
 *   generateMultisigFromHex, TESTNET, P2SH,
 * } from "unchained-bitcoin";
 * import {TrezorSignMultisigTransaction} from "unchained-wallets";
 * const redeemScript = "5...ae";
 * const inputs = [
 *   {
 *     txid: "8d276c76b3550b145e44d35c5833bae175e0351b4a5c57dc1740387e78f57b11",
 *     index: 1,
 *     multisig: generateMultisigFromHex(TESTNET, P2SH, redeemScript),
 *     amountSats: '1234000'
 *   },
 *   // other inputs...
 * ];
 * const outputs = [
 *   {
 *     amountSats: '1299659',
 *     address: "2NGHod7V2TAAXC1iUdNmc6R8UUd4TVTuBmp"
 *   },
 *   // other outputs...
 * ];
 * const interaction = new TrezorSignMultisigTransaction({
 *   network: TESTNET,
 *   inputs,
 *   outputs,
 *   bip32Paths: ["m/45'/0'/0'/0", // add more, 1 per input],
 * });
 * const signature = await interaction.run();
 * console.log(signatures);
 * // ["ababab...", // 1 per input]
 * @extends {module:trezor.TrezorInteraction}
 */
export class TrezorSignMultisigTransaction extends TrezorInteraction {

  /**
   * @param {object} options
   * @param {string} options.network - bitcoin network
   * @param {UTXO[]} options.inputs - inputs for the transaction
   * @param {TransactionOutput[]} options.outputs - outputs for the transaction
   * @param {string[]} options.bip32Paths - BIP32 paths on this device to sign with, one per each input
   */
  constructor({network, inputs, outputs, bip32Paths}) {
    super({network});
    this.inputs = inputs;
    this.outputs = outputs;
    this.bip32Paths = bip32Paths;
  }

  /**
   * Adds messages describing the signing flow.
   *
   * @returns {module:interaction.Message[]}
   */
  messages() {
    const messages = super.messages();
    messages.push({state: ACTIVE, level: INFO, text: `Confirm in the Trezor Connect window that you want to 'Sign ${this.network} transaction'.  You may be prompted to enter your PIN.`, code: "trezor.connect.sign"});
    messages.push({state: ACTIVE, level: INFO, text: `You Trezor device will ask you to confirm each output address above with its corresponding output amount.  Check each address and amount carefully against both the values displayed in this application and your own expectations.`, code: "trezor.signing.outputs"});
    messages.push({state: ACTIVE, level: INFO, text: `Finally, your Trezor device will ask you to confirm the overall transaction output amount and fee.  Check both carefully against both the values displayed in this application and your own expectations.`, code: "trezor.signing.final"});
    return messages;
  }

  /**
   * See {@link https://github.com/trezor/connect/blob/v8/docs/methods/signTransaction.md}.
   *
   * @returns {Array&lt;function, Object>}
   */
  connectParams() {
    return [
      TrezorConnect.signTransaction,
      {
        inputs: this.inputs.map((input, inputIndex) => trezorInput(input, this.bip32Paths[inputIndex])),
        outputs: this.outputs.map((output) => trezorOutput(output)),
        coin: this.trezorCoin,
      },
    ];
  }

  /**
   * Parses the signature out of the response payload.
   *
   * @param {Object} payload
   * @returns {string[]} signature -- one signature per input
   */
  parse(payload) {
    return payload.signatures;
  }

}

/**
 * Shows a multisig address on the device and prompts the user to
 * confirm it.
 * 
 * @extends {module:trezor.TrezorInteraction}
 * @example
 * import {
 *   generateMultisigFromPublicKeys, MAINNET, P2SH,
 * } from "unchained-bitcoin";
 * import {TrezorConfirmMultisigAddress} from "unchained-wallets";
 * const multisig = generateMultisigFromPublicKeys(MAINNET, P2SH, 2, "03a...", "03b...");
 * const interaction = new TrezorConfirmMultisigAddress({network: MAINNET, bip32Path: "m/45'/0'/0'/0/0/", multisig});
 * await interaction.run();
 */
export class TrezorConfirmMultisigAddress extends TrezorInteraction {

  /**
   * Most of the information required to confirm a multisig address
   * lives in the `Multisig` object from `unchained-bitcoin`.
   * 
   * @param {object} options
   * @param {string} options.network - bitcoin network
   * @param {string} options.bip32Path - BIP32 path to the public key on this device used in the multisig address
   * @param {Multisig} options.multisig - multisig object
   */
  constructor({network, bip32Path, multisig}) {
    super({network});
    this.bip32Path = bip32Path;
    this.multisig = multisig;
  }

  /**
   * Adds messages about BIP32 path warnings.
   * 
   */
  messages() {
    const messages = super.messages();
    // FIXME add messages!
    return messages;
  }

  /**
   * See {@link https://github.com/trezor/connect/blob/v8/docs/methods/getAddress.md}.
   *
   * @returns {Array&lt;function, Object>}
   */
  connectParams() {
    return [
      TrezorConnect.getAddress,
      {
        path: this.bip32Path, 
        address: multisigAddress(this.multisig), 
        showOnTrezor: true, 
        coin: this.trezorCoin, 
        crossChain: true, 
        multisig: {
          m: multisigRequiredSigners(this.multisig),
          pubkeys: multisigPublicKeys(this.multisig).map((publicKey) => trezorPublicKey(publicKey)),
        },
        scriptType: ADDRESS_SCRIPT_TYPES[multisigAddressType(this.multisig)],
      }
    ];
  }

}

/**
 * Returns the Trezor API version of the given network.
 *
 * @param {string} network - bitcoin network
 * @returns {string}
 */
export function trezorCoin(network) {
  return (network === MAINNET ? "Bitcoin" : "Testnet");
}

function trezorInput(input, bip32Path) {
  const requiredSigners = multisigRequiredSigners(input.multisig);
  const addressType = multisigAddressType(input.multisig);
  const spendType = ADDRESS_SCRIPT_TYPES[addressType];
  return {
    script_type: spendType,
    multisig: {
      m: requiredSigners,
      pubkeys: multisigPublicKeys(input.multisig).map((publicKey) => trezorPublicKey(publicKey)),
      signatures: Array(requiredSigners).fill(''),
    },
    prev_hash: input.txid,
    prev_index: input.index,
    address_n: bip32PathToSequence(bip32Path),
    amount: BigNumber(input.amountSats).toString()
  };
}

function trezorPublicKey(publicKey) {
  return {
    address_n: [],
    node: {
      // FIXME are all these 0's OK?
      depth: 0,
      child_num: 0,
      fingerprint: 0,
      chain_code: '0'.repeat(64),
      public_key: publicKey,
    },
  };
}

function trezorOutput(output) {
  return {
    amount: BigNumber(output.amountSats).toFixed(0),
    address: output.address,
    script_type: 'PAYTOADDRESS',
  };
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-hermit.html">hermit</a></li><li><a href="module-interaction.html">interaction</a></li><li><a href="module-ledger.html">ledger</a></li><li><a href="module-trezor.html">trezor</a></li></ul><h3>Classes</h3><ul><li><a href="module-hermit.HermitDisplayer.html">HermitDisplayer</a></li><li><a href="module-hermit.HermitExportExtendedPublicKey.html">HermitExportExtendedPublicKey</a></li><li><a href="module-hermit.HermitExportPublicKey.html">HermitExportPublicKey</a></li><li><a href="module-hermit.HermitInteraction.html">HermitInteraction</a></li><li><a href="module-hermit.HermitReader.html">HermitReader</a></li><li><a href="module-hermit.HermitSignTransaction.html">HermitSignTransaction</a></li><li><a href="module-interaction.DirectKeystoreInteraction.html">DirectKeystoreInteraction</a></li><li><a href="module-interaction.IndirectKeystoreInteraction.html">IndirectKeystoreInteraction</a></li><li><a href="module-interaction.KeystoreInteraction.html">KeystoreInteraction</a></li><li><a href="module-interaction.UnsupportedInteraction.html">UnsupportedInteraction</a></li><li><a href="module-ledger.LedgerBitcoinInteraction.html">LedgerBitcoinInteraction</a></li><li><a href="module-ledger.LedgerDashboardInteraction.html">LedgerDashboardInteraction</a></li><li><a href="module-ledger.LedgerExportPublicKey.html">LedgerExportPublicKey</a></li><li><a href="module-ledger.LedgerGetMetadata.html">LedgerGetMetadata</a></li><li><a href="module-ledger.LedgerInteraction.html">LedgerInteraction</a></li><li><a href="module-ledger.LedgerSignMultisigTransaction.html">LedgerSignMultisigTransaction</a></li><li><a href="module-ledger-LedgerExportHDNode.html">LedgerExportHDNode</a></li><li><a href="module-trezor.TrezorConfirmMultisigAddress.html">TrezorConfirmMultisigAddress</a></li><li><a href="module-trezor.TrezorExportExtendedPublicKey.html">TrezorExportExtendedPublicKey</a></li><li><a href="module-trezor.TrezorExportHDNode.html">TrezorExportHDNode</a></li><li><a href="module-trezor.TrezorExportPublicKey.html">TrezorExportPublicKey</a></li><li><a href="module-trezor.TrezorGetMetadata.html">TrezorGetMetadata</a></li><li><a href="module-trezor.TrezorInteraction.html">TrezorInteraction</a></li><li><a href="module-trezor.TrezorSignMultisigTransaction.html">TrezorSignMultisigTransaction</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ConfirmMultisigAddress">ConfirmMultisigAddress</a></li><li><a href="global.html#DIRECT_KEYSTORES">DIRECT_KEYSTORES</a></li><li><a href="global.html#ExportExtendedPublicKey">ExportExtendedPublicKey</a></li><li><a href="global.html#ExportPublicKey">ExportPublicKey</a></li><li><a href="global.html#GetMetadata">GetMetadata</a></li><li><a href="global.html#INDIRECT_KEYSTORES">INDIRECT_KEYSTORES</a></li><li><a href="global.html#KEYSTORES">KEYSTORES</a></li><li><a href="global.html#SignMultisigTransaction">SignMultisigTransaction</a></li><li><a href="global.html#VERSION">VERSION</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Jan 05 2020 16:43:31 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
